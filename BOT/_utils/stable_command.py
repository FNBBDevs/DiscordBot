import os
import json
import time
import openai
import base64
import typing
import discord
import asyncio
import requests
import functools

from PIL import Image

from .views import ImagineView
from .embeds import get_imagine_embed
from .stable_diffusion import stable_base_json
from .queueing import StableQueue, StableQueueItem


def to_thread(func: typing.Callable) -> typing.Coroutine:
    """Function to wrap another function in a to_thread
    so it can be awaited and non-blocking

    Args:
        func (typing.Callable): function to wrap

    Returns:
        typing.Coroutine: _description_
    """
    @functools.wraps(func)
    async def wrapper(*args, **kwargs):
        return await asyncio.to_thread(func, *args, **kwargs)

    return wrapper


class StableCommandCenter:
    """
    Class for facilitating Imagine requests.
    """
    def __init__(self, current_directory: str, client: discord.Client):
        """Constructor for the StableCommandCenter

        Args:
            current_directory (str): current working dir of the bot
            client (discord.Client): discord client
        """
        self.current_directory = f"{current_directory}\\BOT\\_utils\\_tmp\\stable_diffusion"
        self.client = client
        self.queue = StableQueue()
        self.processing = False
        self.queue_empty = True

    async def delegate(self, stable_request: StableQueueItem):
        """Function to delegate an incoming imagine request.
        - Do we process it right away?
        - Do we add it to a queue?

        Args:
            stable_request (StableQueueItem): request to be generated
        """
        # add to queue if processing
        if self.processing:
            await self.add_to_queue(stable_request)
        else:
            # process the request
            self.processing = True
            embed, file, view, channel  = await self.process_stable_queue_item(item=stable_request)

            # send the embed
            await channel.send(
                embed=embed, 
                file=file,
                view=view
            )
                 
            # check if we need to process a queue       
            await self.check_processing()
            
    async def add_to_queue(self, item: StableQueueItem):
        """Function to add a reuqest to the queue

        Args:
            item (StableQueueItem): request to be generated
        """
        self.queue_empty = False
        self.queue.add(item)

    async def check_processing(self):
        """Function to determine if we have a queue we need to process.
        Other wise we can free up the processing var
        """
        # check if we need to process a queue
        if len(self.queue) > 0:
            await self.process_queue()
        else:
            self.processing = False

    @to_thread
    def call_txt2img(self, payload: dict):
        """Function to call the stable diffusion API.

        Args:
            payload (dict): request to be generated.

        Returns:
            _type_: JSON response from the stable API.
        """
        # call the api
        response = json.loads(
            requests.post(
                url=r"http://127.0.0.1:7861/sdapi/v1/txt2img", json=payload
            ).content.decode("utf8")
        )
        return response

    def save_image(self, path: str, data: str):
        """Function to save the base64 data to the path

        Args:
            path (str): path to save image
            data (str): base64 image data
        """
        # open the path and write the data
        with open(
            path,
            "wb",
        ) as image_file:
            image_file.write(base64.b64decode(data))

    def make_grid_image(self, stable_id: str):
        """Function to take all images generated by the request and put
        them into a grid. 1 - 4 images.

        Args:
            stable_id (str): id of the request
        """
        # create a 2x2 grid of the images to send (like mid journey)
        pil_images = []
        # grab each image from the folder that maps this this stable_id
        for image_file in os.listdir(f"{self.current_directory}\\{stable_id}"):
            if "grid" not in image_file and "json" not in image_file:
                pil_images.append(
                    Image.open(f"{self.current_directory}\\{stable_id}\\{image_file}")
                )

        pil_images_count = len(pil_images)

        # add the images to each corner of the grid
        if pil_images_count == 1:
            # empty image
            grid_image = Image.new(
                "RGB", (pil_images[0].width, pil_images[0].height)
            )
            grid_image.paste(pil_images[0], (0, 0))
        elif pil_images_count == 2:
            # empty image
            grid_image = Image.new(
                "RGB", (pil_images[0].width * 2, pil_images[0].height)
            )
            grid_image.paste(pil_images[0], (0, 0))
            grid_image.paste(pil_images[1], (pil_images[0].width, 0))
        elif pil_images_count in [3, 4]:
            # empty image
            grid_image = Image.new(
                "RGB", (pil_images[0].width * 2, pil_images[0].height * 2)
            )
            grid_image.paste(pil_images[0], (0, 0))
            grid_image.paste(pil_images[1], (pil_images[0].width, 0))
            if pil_images_count == 4:
                grid_image.paste(pil_images[2], (0, pil_images[0].height))
                grid_image.paste(pil_images[3], (pil_images[0].width, pil_images[0].height))
            else:
                grid_image.paste(pil_images[2], (pil_images[0].width // 2, pil_images[0].height))

        # down size the image
        grid_image = grid_image.resize(
            (grid_image.width // 2, grid_image.height // 2),
            Image.Resampling.BICUBIC,
        )

        # save the grid image to the folder that maps to the stable_id
        grid_image.save(f"{self.current_directory}\\{stable_id}\\{stable_id}_grid.png")

    async def process_queue(self):
        """Function to process the queue until it is empty
        """
        
        # loop until the queue is empty
        while len(self.queue) != 0:
            # grab an element from the queue
            stable_queue_item = self.queue.pop()
            # get the embed, image file, view, and channel to send too
            embed, file, view, channel = await self.process_stable_queue_item(item=stable_queue_item)
            # send the embed to the user
            await channel.send(
                embed=embed, 
                file=file,
                view=view
            )
        # we are done processing now
        self.processing = False
        self.queue_empty = True

    async def process_stable_queue_item(self, item: StableQueueItem):
        """Main function to call the API and save the images.

        Args:
            item (StableQueueItem): request to be generated

        Returns:
            _type_: embed, image file, discord view, channel to send the embed to
        """
        
        user = item.user
        user_avatar = item.user_avatar
        channel = item.channel
        stable_id = item.stable_id
        source_channel = self.client.get_channel(channel)
        
        # make the folder for this reuqest
        os.mkdir(f"{self.current_directory}\\{stable_id}")
        
        # save the request data to a json file (incase a user clicks the redo button)
        with open(f"{self.current_directory}\\{stable_id}\\info.json", "w") as json_file:
            info_json = {
                "prompt": item.prompt,
                "negative_prompt": item.negative_prompt,
                "quality": item.quality,
                "cfg_scale": item.cfg_scale,
                "steps": item.steps,
                "seed": item.seed,
                "upscale_model": item.upscale_model,
                "sampler": item.sampler,
                "channel": item.channel,
                "stable_id": stable_id,
                "user": item.user,
                "user_avatar": item.user_avatar if isinstance(item.user_avatar, str) else item.user_avatar.url,
                "images": item.images
            }
            
            json_file.write(json.dumps(info_json, indent=3))

        # fill out the payload that will be sent to the stable diffusion API
        txt2img_request_payload = stable_base_json.copy()
        txt2img_request_payload["hr_negative_prompt"] = item.negative_prompt
        txt2img_request_payload["negative_prompt"] = item.negative_prompt
        txt2img_request_payload["hr_prompt"] = item.prompt
        txt2img_request_payload["prompt"] = item.prompt
        txt2img_request_payload["hr_scale"] = item.quality
        txt2img_request_payload["cfg_scale"] = item.cfg_scale
        txt2img_request_payload["steps"] = item.steps
        txt2img_request_payload["seed"] = item.seed
        txt2img_request_payload["hr_upscaler"] = item.upscale_model
        txt2img_request_payload["n_iter"] = item.images
        if item.sampler:
            txt2img_request_payload["sampler_name"] = item.sampler

        # call the API
        response = await self.call_txt2img(payload=txt2img_request_payload)

        # save each image returned indexed 1-4
        for idx, image in enumerate(response["images"]):
            self.save_image(
                path=f"{self.current_directory}\\{stable_id}\\{stable_id}_{idx}.png",
                data=image,
            )

        # make the grid image that will be sent to discord
        self.make_grid_image(stable_id=stable_id)

        # generate the embed and file needed to send to discord
        imagine_emebed, imagine_image_file = get_imagine_embed(
            footer_text="Image generated by: ",
            footer_usr=user,
            footer_img=user_avatar,
            stable_id=stable_id,
        )
        
        # create the view that will be sent to discord
        imagine_view = ImagineView(
            stable_id=stable_id,
            prompt=item.prompt,
            negative=item.negative_prompt,
            quality=item.quality,
            cfg=item.cfg_scale,
            steps=item.steps,
            seed=item.seed,
            upscale_model=item.upscale_model,
            sampler=item.sampler,
        )
        
        imagine_view.children[0].disabled = not item.images >= 1
        imagine_view.children[1].disabled = not item.images >= 2
        imagine_view.children[2].disabled = not item.images >= 3
        imagine_view.children[3].disabled = not item.images >= 4
        
        # return these elements
        return imagine_emebed, imagine_image_file, imagine_view, source_channel
